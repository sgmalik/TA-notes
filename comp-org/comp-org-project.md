# Computer Organization Final Project Ideas

---

## 1. Mini ARM Emulator

**Difficulty:** Intermediate → Advanced  

### Description
Students will build a Python-based simulator for a small subset of the ARM instruction set. The program should maintain a register file, memory space, and execute instructions like `ADD`, `SUB`, `LOAD`, `STORE`, and `B`. The system will display register and memory states after each instruction.

### Textbook Connection
- **Chapter 2: Instructions: Language of the Computer** — instruction formats, registers, addressing modes  
- **Chapter 4: The Processor** — datapath, control flow  
- **Chapter 6: Parallel Processors** — extensions could include pipelining  

### Learning Benefits
- Reinforces the connection between high-level programming constructs and their low-level implementations.  
- Provides insight into how CPUs execute instructions step-by-step.  
- Encourages systematic thinking about instruction execution, memory access, and control flow.  
- By writing the simulator, students "play computer," which solidifies ISA fundamentals.

### Suggested Approach 
- Start in **Python**: implement a register file (`R0–R7`), a block of memory, and a simple instruction parser.  
- Support a small set of instructions first (`ADD`, `SUB`, `MOV`), then extend to memory (`LDR`, `STR`) and branches (`B`).  
- Use **unit tests** to check each instruction.  
- Optional: extend with flags (Zero, Negative) or pipelining.  
- Use **C** to write small test programs, compile to ARM assembly (with `gcc -S`), then run them on the emulator.  

---

## 2. Cache Simulator

**Difficulty:** Intermediate

### Description
Students create a program that simulates CPU caches under different configurations. Input is a trace of memory accesses (provided by instructor or generated by a test program). Students must implement direct-mapped, set-associative, and fully associative caches, then compare hit/miss rates.

### Textbook Connection
- **Chapter 5: The Memory Hierarchy** — caching principles, spatial/temporal locality, replacement policies  
- **Chapter 1: Introduction** — performance metrics (CPI, AMAT)  

### Learning Benefits
- Makes abstract cache design concrete by requiring students to model it computationally.  
- Highlights the performance impact of memory hierarchy on programs.  
- Shows how algorithm choice (e.g., array vs linked list) interacts with hardware performance.  
- Provides a bridge to real-world system design trade-offs in computer architecture.

### Suggested Approach
- In **Python**, represent cache as a list of sets. Each set stores tags, valid bits, and optionally LRU counters.  
- Begin with a direct-mapped cache. Verify with small memory traces.  
- Extend to 2-way or 4-way set associative, then fully associative.  
- Add replacement policies (FIFO, LRU).  
- Measure hit/miss rate on provided memory traces or C programs compiled with instrumentation. 

---

## 3. Virtual Memory Visualizer

**Difficulty:** Intermediate

### Description
A Python program that simulates virtual-to-physical address translation. Students implement a simple page table and a translation lookaside buffer (TLB). Given memory accesses, the program shows address breakdown (page number + offset), whether a page fault occurs, and the final physical address.

### Textbook Connection
- **Chapter 5: The Memory Hierarchy** — paging, virtual memory, TLBs, page faults  
- **Chapter 7: Storage and I/O** — connection between memory and storage for page swapping  

### Learning Benefits
- Reinforces the concept of abstraction in memory systems.  
- Helps students understand how virtual memory protects and shares resources.  
- Develops appreciation for the complexity of address translation and performance costs of page faults.  
- Provides a visual, step-by-step model of a key real-world system.

### Suggested Approach
- Implement in **Python** a page table mapping virtual to physical pages.  
- Simulate TLB lookup: if not found, fall back to page table.  
- Handle page faults by printing "Page Fault: Loading Page X".  
- Provide a GUI/CLI display showing breakdown of address: `(Page #, Offset)` → `(Frame #, Offset)`.  
- Optionally use a small C program to generate memory accesses.  

---

## 4. Pipeline Simulator

**Difficulty:** Advanced

### Description
Students model a 5-stage instruction pipeline (Fetch, Decode, Execute, Memory, Writeback). Given a short program, the simulator should display instructions in each stage per cycle, and handle hazards by stalling or forwarding.

### Textbook Connection
- **Chapter 4: The Processor** — single-cycle datapath and pipelining concepts  
- **Chapter 6: Parallel Processors** — pipeline hazards, instruction-level parallelism  

### Learning Benefits
- Makes visible the benefits and challenges of pipelining.  
- Demonstrates hazards and why they reduce performance.  
- Provides hands-on experience with design trade-offs (stalling vs forwarding).  
- Reinforces how modern CPUs improve throughput without changing clock speed.

### Suggested Approach
- In **Python**, represent each stage (IF, ID, EX, MEM, WB) as a structure.  
- Each cycle, advance instructions through stages.  
- Start with no hazards. Then add hazard detection:  
  - Data hazards → stall or forward.  
  - Control hazards → flush on taken branch.  
- Provide a timeline table output (cycle vs stage).  
- Use simple ARM-like instructions as input.  

---

## 5. ARM-to-Python Translator

**Difficulty:** Introductory -> Intermediate

### Description
A tool that parses a small subset of ARM assembly instructions and outputs equivalent Python code. For example, `ADD r0, r1, r2` might be converted into `r0 = r1 + r2`.

### Textbook Connection
- **Chapter 2: Instructions** — ARM ISA basics  
- **Chapter 3: Arithmetic for Computers** — integer/floating-point operations  
- **Chapter 4: The Processor** — control flow and branches  

### Learning Benefits
- Strengthens the student’s ability to move between low-level assembly and high-level constructs.  
- Develops parsing and translation skills, useful in compilers and interpreters.  
- Shows concretely how compilers "map" high-level code to low-level instructions.  

### Suggested Approach
- In **Python**, parse a text file of ARM instructions.  
- Map instructions to equivalent Python statements (`ADD r0, r1, r2` → `r0 = r1 + r2`).  
- Maintain registers as dictionary variables.  
- Extend with branching (`B label` → Python `goto`-like emulation using loops/dicts).  
- Verify correctness by running both ARM code in an emulator and the translated Python.  

---

## 6. Disassembly Explorer

**Difficulty:** Introductory

### Description
Students write small C programs (loops, conditionals, functions), compile them for ARM using a provided toolchain, and then analyze the disassembly. They must explain how constructs like loops, if-statements, and function calls appear at the assembly level.

### Textbook Connection
- **Chapter 2: Instructions** — instruction formats and branching  
- **Chapter 3: Arithmetic** — arithmetic instructions and operations  
- **Chapter 4: The Processor** — execution of control flow  

### Learning Benefits
- Builds confidence reading and reasoning about real assembly code.  
- Connects high-level programming experience to machine-level representation.  
- Reinforces compiler role in bridging high-level abstractions with hardware execution.

### Suggested Approach
- Write small **C programs** (loops, conditionals, recursion).  
- Compile with ARM toolchain (`gcc -S -march=armv7-a`).  
- Analyze generated `.s` assembly.  
- In **Python**, write a helper script that highlights instruction types (data movement, arithmetic, branch).  
- Students prepare a report showing how high-level constructs map to ARM assembly.

---

## 7. Multithreaded Matrix Multiply

**Difficulty:** Intermediate

### Description
Implement matrix multiplication sequentially, then with Python’s `threading` or `multiprocessing`. Measure runtime for increasing matrix sizes and thread counts, and compare results.

### Textbook Connection
- **Chapter 1: Introduction** — performance and parallelism  
- **Chapter 6: Parallel Processors** — multicore execution, Amdahl’s Law  

### Learning Benefits
- Demonstrates benefits and limitations of parallel execution.  
- Reinforces key performance principles like scalability and bottlenecks.  
- Provides hands-on context for multicore processor discussions.  
- Shows why parallelism is not “free” and introduces real-world considerations (synchronization, overhead).

### Suggested Approach
- Start with sequential matrix multiplication in **Python**.  
- Time execution for increasing matrix sizes.  
- Add threading with `multiprocessing` or `concurrent.futures`.  
- Measure speedup vs. number of threads. Compare to Amdahl’s Law.  
- Optionally implement one version in **C** for speed comparison with Python.  

---

## 8. Encryption Engine

**Difficulty:** Introductory -> Intermeidate

### Description
Students implement classical ciphers (Caesar, Vigenère, simple RSA). For each, they analyze performance in terms of number of operations and relate to hardware instruction efficiency. Bitwise operations should be emphasized.

### Textbook Connection
- **Chapter 3: Arithmetic for Computers** — binary, modular arithmetic, bitwise ops  
- **Chapter 5: The Memory Hierarchy** — performance of repeated operations  

### Learning Benefits
- Provides a fun, applied domain (security/cryptography) while reinforcing low-level arithmetic.  
- Encourages students to think about efficiency of algorithms at the hardware level.  
- Connects abstract arithmetic to a concrete application area.  

### Suggested Approach
- Implement Caesar and Vigenère ciphers in **Python** (string manipulation, modular arithmetic).  
- Add RSA-like encryption with modular exponentiation.  
- Optimize by moving some bitwise-heavy parts (e.g., XOR, shifts) into **C** for comparison.  
- Profile runtime for different input sizes, relate to complexity. 

---

## 9. CPU Scheduling Simulator

**Difficulty:** Introductory

### Description
Implement scheduling algorithms (FCFS, Round Robin, Shortest Job First). The simulator outputs Gantt charts of job execution, average turnaround, and waiting times.

### Textbook Connection
- **Chapter 7: Storage and I/O** — I/O scheduling, performance metrics  
- Reinforces general **performance measurement** principles introduced in **Chapter 1**  

### Learning Benefits
- Provides a bridge between hardware organization and operating systems.  
- Demonstrates how scheduling affects perceived performance.  
- Encourages visualization of processes over time, reinforcing parallelism concepts.  

### Suggested Approach
- In **Python**, simulate jobs with `(arrival time, burst time)`.  
- Implement FCFS, Round Robin, SJF.  
- Produce Gantt chart output (ASCII or matplotlib).  
- Calculate turnaround time, waiting time, CPU utilization.  
- Optionally add priority scheduling.

---

## 10. Group Challenge: Toy Computer System

**Difficulty:** Advanced -> Collaborative

### Description
Class divides into small teams. Each team contributes one part of a toy computer:  
- Group A: Define an instruction set.  
- Group B: Write an assembler.  
- Group C: Build an emulator.  
- Group D: Provide sample programs and test cases.  

Together, the groups integrate their work to form a complete system.

### Textbook Connection
- **Chapter 2: Instructions** — designing an ISA  
- **Chapter 4: The Processor** — datapath design  
- **Chapter 5: The Memory Hierarchy** — simulating memory  
- **Chapter 6: Parallelism** — potential extensions  

### Learning Benefits
- Mimics real-world collaboration in computer architecture teams.  
- Gives students a holistic view of how different parts of a system fit together.  
- Provides flexibility for both creative design and rigorous implementation.  
- Encourages teamwork, integration, and testing skills.

### Suggested Approach
- Divide class into teams:  
  - **ISA Design**: Define registers, instructions, encoding format.  
  - **Assembler**: Translate assembly → binary.  
  - **Emulator**: Execute binary instructions in Python.  
  - **Programs**: Write test programs in C, compile, hand-translate into toy ISA.  
- Integration day: run end-to-end from program → assembly → machine code → execution.  
- Extensions: add pipeline, caching, or simple I/O.  

